"""Tests of the builder registry."""

import pytest
import warnings
<<<<<<< HEAD
=======
from typing import Type
>>>>>>> temp-branch

from bs4 import BeautifulSoup
from bs4.builder import (
    builder_registry as registry,
<<<<<<< HEAD
    HTMLParserTreeBuilder,
    TreeBuilderRegistry,
)
=======
    TreeBuilder,
    TreeBuilderRegistry,
)
from bs4.builder._htmlparser import HTMLParserTreeBuilder
>>>>>>> temp-branch

from . import (
    HTML5LIB_PRESENT,
    LXML_PRESENT,
)

if HTML5LIB_PRESENT:
<<<<<<< HEAD
    from bs4.builder import HTML5TreeBuilder

if LXML_PRESENT:
    from bs4.builder import (
        LXMLTreeBuilderForXML,
        LXMLTreeBuilder,
        )
=======
    from bs4.builder._html5lib import HTML5TreeBuilder

if LXML_PRESENT:
    from bs4.builder._lxml import (
        LXMLTreeBuilderForXML,
        LXMLTreeBuilder,
    )
>>>>>>> temp-branch


# TODO: Split out the lxml and html5lib tests into their own classes
# and gate with pytest.mark.skipIf.
class TestBuiltInRegistry(object):
    """Test the built-in registry with the default builders registered."""

    def test_combination(self):
<<<<<<< HEAD
        assert registry.lookup('strict', 'html') == HTMLParserTreeBuilder
        if LXML_PRESENT:
            assert registry.lookup('fast', 'html') == LXMLTreeBuilder
            assert registry.lookup('permissive', 'xml') == LXMLTreeBuilderForXML
        if HTML5LIB_PRESENT:
            assert registry.lookup('html5lib', 'html') == HTML5TreeBuilder

    def test_lookup_by_markup_type(self):
        if LXML_PRESENT:
            assert registry.lookup('html') == LXMLTreeBuilder
            assert registry.lookup('xml') == LXMLTreeBuilderForXML
        else:
            assert registry.lookup('xml') == None
            if HTML5LIB_PRESENT:
                assert registry.lookup('html') == HTML5TreeBuilder
            else:
                assert registry.lookup('html') == HTMLParserTreeBuilder

    def test_named_library(self):
        if LXML_PRESENT:
            assert registry.lookup('lxml', 'xml') == LXMLTreeBuilderForXML
            assert registry.lookup('lxml', 'html') == LXMLTreeBuilder
        if HTML5LIB_PRESENT:
            assert registry.lookup('html5lib') == HTML5TreeBuilder

        assert registry.lookup('html.parser') == HTMLParserTreeBuilder

    def test_beautifulsoup_constructor_does_lookup(self):

        with warnings.catch_warnings(record=True) as w:
=======
        assert registry.lookup("strict", "html") == HTMLParserTreeBuilder
        if LXML_PRESENT:
            assert registry.lookup("fast", "html") == LXMLTreeBuilder
            assert registry.lookup("permissive", "xml") == LXMLTreeBuilderForXML
        if HTML5LIB_PRESENT:
            assert registry.lookup("html5lib", "html") == HTML5TreeBuilder

    def test_lookup_by_markup_type(self):
        if LXML_PRESENT:
            assert registry.lookup("html") == LXMLTreeBuilder
            assert registry.lookup("xml") == LXMLTreeBuilderForXML
        else:
            assert registry.lookup("xml") is None
            if HTML5LIB_PRESENT:
                assert registry.lookup("html") == HTML5TreeBuilder
            else:
                assert registry.lookup("html") == HTMLParserTreeBuilder

    def test_named_library(self):
        if LXML_PRESENT:
            assert registry.lookup("lxml", "xml") == LXMLTreeBuilderForXML
            assert registry.lookup("lxml", "html") == LXMLTreeBuilder
        if HTML5LIB_PRESENT:
            assert registry.lookup("html5lib") == HTML5TreeBuilder

        assert registry.lookup("html.parser") == HTMLParserTreeBuilder

    def test_beautifulsoup_constructor_does_lookup(self):
        with warnings.catch_warnings(record=True):
>>>>>>> temp-branch
            # This will create a warning about not explicitly
            # specifying a parser, but we'll ignore it.

            # You can pass in a string.
            BeautifulSoup("", features="html")
            # Or a list of strings.
            BeautifulSoup("", features=["html", "fast"])
            pass
<<<<<<< HEAD
            
=======

>>>>>>> temp-branch
        # You'll get an exception if BS can't find an appropriate
        # builder.
        with pytest.raises(ValueError):
            BeautifulSoup("", features="no-such-feature")

<<<<<<< HEAD
=======

>>>>>>> temp-branch
class TestRegistry(object):
    """Test the TreeBuilderRegistry class in general."""

    def setup_method(self):
        self.registry = TreeBuilderRegistry()

<<<<<<< HEAD
    def builder_for_features(self, *feature_list):
        cls = type('Builder_' + '_'.join(feature_list),
                   (object,), {'features' : feature_list})
=======
    def builder_for_features(self, *feature_list: str) -> Type[TreeBuilder]:
        cls = type(
            "Builder_" + "_".join(feature_list), (object,), {"features": feature_list}
        )
>>>>>>> temp-branch

        self.registry.register(cls)
        return cls

    def test_register_with_no_features(self):
        builder = self.builder_for_features()

        # Since the builder advertises no features, you can't find it
        # by looking up features.
<<<<<<< HEAD
        assert self.registry.lookup('foo') is None
=======
        assert self.registry.lookup("foo") is None
>>>>>>> temp-branch

        # But you can find it by doing a lookup with no features, if
        # this happens to be the only registered builder.
        assert self.registry.lookup() == builder

    def test_register_with_features_makes_lookup_succeed(self):
<<<<<<< HEAD
        builder = self.builder_for_features('foo', 'bar')
        assert self.registry.lookup('foo') is builder
        assert self.registry.lookup('bar') is builder

    def test_lookup_fails_when_no_builder_implements_feature(self):
        builder = self.builder_for_features('foo', 'bar')
        assert self.registry.lookup('baz') is None

    def test_lookup_gets_most_recent_registration_when_no_feature_specified(self):
        builder1 = self.builder_for_features('foo')
        builder2 = self.builder_for_features('bar')
=======
        builder = self.builder_for_features("foo", "bar")
        assert self.registry.lookup("foo") is builder
        assert self.registry.lookup("bar") is builder

    def test_lookup_fails_when_no_builder_implements_feature(self):
        assert self.registry.lookup("baz") is None

    def test_lookup_gets_most_recent_registration_when_no_feature_specified(self):
        self.builder_for_features("foo")
        builder2 = self.builder_for_features("bar")
>>>>>>> temp-branch
        assert self.registry.lookup() == builder2

    def test_lookup_fails_when_no_tree_builders_registered(self):
        assert self.registry.lookup() is None

    def test_lookup_gets_most_recent_builder_supporting_all_features(self):
<<<<<<< HEAD
        has_one = self.builder_for_features('foo')
        has_the_other = self.builder_for_features('bar')
        has_both_early = self.builder_for_features('foo', 'bar', 'baz')
        has_both_late = self.builder_for_features('foo', 'bar', 'quux')
        lacks_one = self.builder_for_features('bar')
        has_the_other = self.builder_for_features('foo')

        # There are two builders featuring 'foo' and 'bar', but
        # the one that also features 'quux' was registered later.
        assert self.registry.lookup('foo', 'bar') == has_both_late

        # There is only one builder featuring 'foo', 'bar', and 'baz'.
        assert self.registry.lookup('foo', 'bar', 'baz') == has_both_early

    def test_lookup_fails_when_cannot_reconcile_requested_features(self):
        builder1 = self.builder_for_features('foo', 'bar')
        builder2 = self.builder_for_features('foo', 'baz')
        assert self.registry.lookup('bar', 'baz') is None
=======
        self.builder_for_features("foo")
        self.builder_for_features("bar")
        has_both_early = self.builder_for_features("foo", "bar", "baz")
        has_both_late = self.builder_for_features("foo", "bar", "quux")
        self.builder_for_features("bar")
        self.builder_for_features("foo")

        # There are two builders featuring 'foo' and 'bar', but
        # the one that also features 'quux' was registered later.
        assert self.registry.lookup("foo", "bar") == has_both_late

        # There is only one builder featuring 'foo', 'bar', and 'baz'.
        assert self.registry.lookup("foo", "bar", "baz") == has_both_early

    def test_lookup_fails_when_cannot_reconcile_requested_features(self):
        self.builder_for_features("foo", "bar")
        self.builder_for_features("foo", "baz")
        assert self.registry.lookup("bar", "baz") is None
>>>>>>> temp-branch
